# CLI 演習

## コマンドが生まれた経緯～edエディタからgrep, sedコマンドへ～

### grep, sedとは
- **grep**:
    - global regular expression print
    - 正規表現による文字列検索が可能なコマンド
- **sed**:
    - stream editor
    - ストリームの特定行の表示、文字列置換等が可能なコマンド

### grep, sedが作られた経緯
> ベル研のMcIlroyが、ファイルに保存された文章をedというエディタでいじっていた
> edには文字列検索の機能があり、これを使って、ある作業をしていたが、edのメモリの上限に引っかかって作業に難渋してしまった
> これは、edと始めとするあらゆるエディタが、その性質上、扱うファイルの内容や変更の履歴をすべてメモリ上に読み込むからである
> そこでMcIlroyは、同じくベル研のRitchieに「edから検索機能を取り出して別のプログラムにしてほしい」という依頼を出した
> こうして、edの検索コマンド `g/<re>/p` が独立し、grepとなった

grepはメモリをほとんど使わない

なぜならgrepは1行1行ファイルを読んでいき、検索対象の文字列が見つかったときに画面に字を出すだけで、ファイルの内容を全部メモリに読み込む必要がないからである

このように「エディタから機能をコマンドとして切り離す」という着想を得たことで、McIlroyはストレスなく仕事に集中できるようになった

さらにその後、「行を表示する」「文字列を置換する」という機能を独立させ、sedが完成することになる

***

## ed, grep, sed 演習

※この演習では、作業ディレクトリを明示するため `作業ディレクトリ$ コマンド` という形式でコマンドラインを表示している

- 作業ディレクトリ `practice-01` を作る
    ```sh
    # practice-01 ディレクトリ作成
    ~/$ mkdir practice-01

    # practice-01 ディレクトリに移動
    ~/$ cd practice-01
    ```
- 演習用ファイル `practice-01/file-01` を作成する
    ```bash
    # file-01 ファイルを新規作成
    ~/practice-01/$ touch file-01

    # file-01 ファイルを編集
    ~/practice-01/$ vi file-01
    ### <file-01>
    # i キー => 編集モードで以下のテキストを入力
    This is contents of file!
    This file is created by Linux terminal.
    # Esc キー => :wq => 保存・終了
    ### </file-01>
    ```
- [ ] `ed`エディタを使ってファイル編集
    - 以下の `※コメント` は、McIlroyがメモリ不足になった原因
    - `:` は ed エディタのコマンド入力を明示する接頭辞のため、実際には入力しない
        ```sh
        # ed ターミナルエディタを使って file-01 を開く
        ~/practice-01/$ ed file-01
        66 # <= 最初にファイルの情報（文字数）が表示される（※メモリ上に全ての内容が読み込まれる）
        : 1p  # <= 1行目を表示(print)せよ（: は入力しない）
        This is contents of file!
        : 3p  # <= 3行目を表示(print)せよ
        ? # <= エラー: 存在しない行
        : g/Linux/p  # <= "Linux"を含む行を全体(global)から検索して表示(print)せよ
                     #    `g/<re>/p` => grep というコマンド名の基になったコマンド
        This file is created Linux terminal.
        : s/Linux/Ubuntu/  # <= "Linux"を"Ubuntu"に置換(substitute)せよ
        : 2p  # <= 2行目を表示(print)せよ
        This file is created by Ubuntu terminal.
            # ↑ Linux が Ubuntu に変換されている
            ## ※この時点では、ファイルに反映はされておらず、メモリ上に保存されているだけ
        : w  # <= ファイルに書き込み(write)せよ
        67  # <= 書き換え後のファイルの情報（文字数）
        : q  # <= 終了(quit)せよ
        ```
- [ ] `grep` で文字列検索
    ```bash
    # grep で file-01 ファイルから "Ubuntu" を含む行を検索
    ## grep '検索対象文字列' <ファイル> (※正規表現使用可)
    ~/practice-01/$ grep 'Ubuntu' file-01
    This file is created by Ubuntu terminal.
    ```
- [ ] `sed` でファイル編集
    ```bash
    # sed で file-01 ファイルの1行目表示
    ## sed -n <行>p <ファイル>
    ~/practice-01/$ sed -n 1p file-01
    This is contents of file!

    # file-01 ファイル内の "Ubuntu" を "Linux" に置換
    ## sed 's/<置換対象文字列>/<置換後文字列>/' <ファイル> (※正規表現使用可)
    ~/practice-01/$ sed 's/Ubuntu/Linux/' file-01
    This is contents of file!
    This file is created by Linux terminal.

    # ※↑ 実際に file-01 の中身が書き換わるわけではない

    # file-01 ファイル内の "Ubuntu" を "Linux" に置換し、file-02 ファイルにリダイレクト
    ## リダイレクトにより、edエディタにおける `w` コマンドの代わりの操作が可能
    ## なお、file-02 ではなく直接 file-01 ファイルにリダイレクト(上書き)しようとすると中身が全部消えるため注意！
    ~/practice-01/$ sed 's/Ubuntu/Linux/' file-01 > file-02

    # file-01 を sed で置換して直接 file-01 に上書きリダイレクトしてみる
    ## => file-01 の中身が消えてしまうのを確認する（cat <ファイル> コマンド）
    ~/practice-01/$ sed 's/Ubuntu/Linux/' file-01 > file-01
    ~/practice-01/$ cat file-01

    # file-02 を file-01 にリネーム（上書き）
    ~/practice-01/$ mv file-02 file-01

    # 内容を確認
    ~/practice-01/$ cat file-01
    This is contents of file!
    This file is created by Linux terminal.  # <= "Ubuntu" が "Linux" に置換されている
    ```

***

## パイプとソフトウェアツール

### パイプ
「edというエディタからgrep, sedという単機能のコマンドを切り離す」という方法を思いついたことで、効率の良い作業が可能となった

さらにMcIlroyは、これらのコマンドを**パイプ**でつなぐことによって、さらに複雑な作業を実現できることを思いついた

```bash
# file-01 ファイルから "contents" を含む行を検索(grep)し、その行を逆に(rev)する
## 以下の `|` がパイプ: 左側で行われた処理の結果を右側の処理に渡す
~/practice-01/$ grep 'contents' file-01 | rev
!elif fo stnetnoc si sihT
```

このようにパイプでつなぐことにより、一つ一つのコマンドをフィルタのように使って、複雑なデータ処理が可能となった

```bash
標準入力 > コマンド1によるフィルタ | コマンド2によるフィルタ | ... > 標準出力
```

###  ソフトウェアツール
上記のような経緯を経て、「コマンドは（edのように機能を抱え込まず）単機能で作るべき」、「どのコマンドもパイプでつなげられるように作るべき」、「複雑なことをするにはコマンドをパイプで組み合わせるべき」、という考えがベル研内で生まれた

そして、この考え方、あるいはコマンド自体を指す**ソフトウェアツール**という言葉が生まれた

この設計思想はやがて**UNIX哲学**としてまとめられ、「データやテキストを処理するOS」としてのUNIXは、ほかのOSに比べて圧倒的な優位に立つことになった

#### UNIXとデータ構造
UNIXが「単機能のコマンドをパイプでつなぐ」という設計思想を持った一方で、edをより強化するという考え方もあった

また、メモリをもっと搭載すればedで取り扱えるファイルも大きくなるため、ユーザとしてはそれで良いし、現に今はこちらの考え方のほうがマジョリティーとなっている

この考え方は、プログラミングの統合開発環境やオフィススイートにつながる思想である

しかし、UNIXは研究所で誕生したため、合理性を追求する方向に進んだ

ここで言う合理性とは、以下の考え方に基づく

- データがすべてに優先する
    - 適切なデータ構造を選べば、アルゴリズムはほとんどの場合に自明となる
    - データ構造が不適切だとプログラムが肥大化し、汚く、遅くなる
    - アルゴリズムではなく、データ構造がプログラミングの中心である

言い換えれば、人が作るでたらめなフォーマットのデータに合わせてプログラムを作るのではなく、適切な構造のデータを人が作るべきだという考え方である

「プログラムのほとんどは例外処理だ」という、プログラマには有名な話があるが、UNIXツールは自分が気に食わない入力、あるいはほかのコマンドが対応していないような入力を相手にしていないため、例外処理が少なくなり効率的となる

一方で、営利目的のソフトウェアは、顧客ありきでユーザービリティが優先されるため、プログラムが肥大化しやすい

これは善悪で語られるべきではなく、「UNIXツール」と「営利ソフトウェア」は相互補完的に発展してきたものであるため、どちらも学ぶことが大切である

#### UNIX哲学
UNIXのように、データをほかと連携しやすい形式に保つという考え方は、そのままコンピュータを超えてほかの機器やコンピュータとの通信でも応用が利く考え方で、これは40年以上も廃れることなく存続してきた

この思想は、Gancarzにより「UNIX哲学」として以下ようにまとめられている

- 小さいものは美しい
- 各プログラムが1つのことをうまくやるようにせよ
- できる限り原型（プロトタイプ）を作れ
- 効率よりも移植しやすさを選べ
- 単純なテキストファイルにデータを格納せよ
- ソフトウェアの効率をきみの優位さとして利用せよ
- 効率と移植性を高めるためにシェルスクリプトを利用せよ
- 束縛するインターフェースは作るな
- すべてのプログラムはフィルタとして振る舞うようにせよ
